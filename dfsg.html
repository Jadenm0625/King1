# Rebuild without f-string to avoid brace escaping; inject DATA_URL via replace.
from pathlib import Path, PurePosixPath
import mimetypes, base64

img_path = Path("/mnt/data/Forest1.jpg")
mime = mimetypes.guess_type(str(img_path))[0] or "image/jpeg"
data_url = "data:{};base64,".format(mime) + base64.b64encode(img_path.read_bytes()).decode("ascii")

html = """<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cabin Defense â€” v12.1 live photo (seamâ€‘fix)</title>
<style>
  html, body { margin:0; height:100%; background:#0b0f14; color:#e6edf3; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  #game { display:block; width:100vw; height:100vh; outline:none; cursor: crosshair; }
  .hud { position: fixed; left: 12px; top: 10px; z-index: 20; background: rgba(13,17,23,.6); backdrop-filter: blur(4px);
    border: 1px solid rgba(255,255,255,.12); border-radius: 14px; padding: 10px 12px; box-shadow: 0 6px 18px rgba(0,0,0,.35);
    line-height: 1.2; font-size: 14px; min-width: 390px; }
  .legend { opacity:.85 }
  .hearts { display:flex; gap:2px; margin:6px 0 2px 0; flex-wrap: wrap; }
  .heart { width:14px; height:14px; background:#ff6b6b; clip-path: polygon(50% 90%, 90% 50%, 75% 20%, 50% 35%, 25% 20%, 10% 50%); opacity:.9 }
  .heart.empty { background:#3a3f47; opacity:.6 }
  .bar { width:100%; height:8px; background:#2a2f36; border-radius:6px; overflow:hidden; margin-top:6px; }
  .bar>i { display:block; height:100%; background:#7fb069 }
  .pill { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12); margin-left:6px; }
  .hint { opacity:.0; font-size:12px; transition: opacity .2s ease; min-height: 1.2em; }
  .controls { margin-top: 6px; display:flex; gap:6px; flex-wrap: wrap; }
  .controls button { background: rgba(255,255,255,0.08); color:#e6edf3; border:1px solid rgba(255,255,255,0.18);
    padding: 4px 8px; border-radius: 8px; cursor: pointer; font-weight: 600; }
  .controls button:hover { background: rgba(255,255,255,0.14); }
  .badge { display:inline-block; min-width: 18px; text-align:center; padding:2px 6px; border-radius:999px; background:#2a2f36; margin-left:6px; }
  .focus { position:fixed; right:12px; top:12px; z-index:10; opacity:.7; font-size:12px; }
</style>
</head>
<body>
<canvas id="game" aria-label="Cabin Defense" tabindex="0"></canvas>
<div class="hud" id="hud">
  <div><b>Cabin Defense â€” v12.1 live photo (seamâ€‘fix)</b></div>
  <div>Map width: <span id="mapw">â€”</span> px (1000 ft @ 1 in/px)</div>
  <div>Time: <span id="timeofday">â€”</span> | Phase: <span id="phase">â€”</span> | Enemies: <span id="enemies">0</span></div>
  <div>Cabin HP: <span id="cabinHP">30</span>/30<div class="bar"><i id="cabinHPBar" style="width:100%"></i></div></div>
  <div>Weapon: <span id="weapon">Sword</span> <span class="pill">Gold: <b id="gold">10</b> ðŸŸ¡</span>
       <span class="pill">Queues â€” Bow:<b id="qBow">0</b> Sword:<b id="qSword">0</b> Hammer:<b id="qHammer">0</b></span></div>
  <div class="legend">
    W/A/D move Â· S crouch Â· LMB sword/shoot Â· RMB aim (bow) Â· Scroll = switch Â· <b>E</b> buy nearby (Tent 2g, Wall 2g, Ranger 3g).
    <br/>Queue tools: <b>1</b>=Bow, <b>2</b>=Sword, <b>3</b>=Hammer (1g each, max 5).
  </div>
  <div class="controls">
    <button id="btnBow">+Bow <span class="badge" id="bBow">0</span></button>
    <button id="btnSword">+Sword <span class="badge" id="bSword">0</span></button>
    <button id="btnHammer">+Hammer <span class="badge" id="bHammer">0</span></button>
  </div>
  <div class="hearts" id="playerHearts"></div>
  <div class="hint" id="hint"></div>
</div>
<div class="focus">Click canvas if keys don't respond.</div>

<script>
'use strict';
(function(){

// ========= UTIL =========
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const now=()=>performance.now();

function showErr(msg){ try{document.getElementById('hint').textContent=String(msg); document.getElementById('hint').style.opacity='1';}catch(e){} }
window.onerror=(m)=>{showErr('Frame error: '+m); return false;};

// ========= CONSTANTS =========
const INCH_PER_PX=1, MAP_FEET=1000, FEET_TO_INCH=12;
const WORLD_WIDTH = MAP_FEET*FEET_TO_INCH*(1/INCH_PER_PX); // 12,000px
const WORLD_HEIGHT=900, GROUND_Y=WORLD_HEIGHT-140;
const DPR=Math.min(window.devicePixelRatio||1, 2.5);
const CAMERA_EASE=0.08;

// ========= CANVAS =========
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d', {alpha:false});
ctx.lineJoin='round'; ctx.lineCap='round';
ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
function resize(){ canvas.width=Math.floor(innerWidth*DPR); canvas.height=Math.floor(innerHeight*DPR);
  canvas.style.width=innerWidth+'px'; canvas.style.height=innerHeight+'px'; ctx.setTransform(DPR,0,0,DPR,0,0);}
addEventListener('resize', resize, {passive:true}); resize();
canvas.focus(); canvas.addEventListener('click', ()=>canvas.focus());

// HUD refs
const hudMapW=document.getElementById('mapw'), hudTOD=document.getElementById('timeofday'), hudPhase=document.getElementById('phase'), hudEnemies=document.getElementById('enemies');
const hudWeapon=document.getElementById('weapon'), hudHearts=document.getElementById('playerHearts'), hudGold=document.getElementById('gold'), hudCabHP=document.getElementById('cabinHP'), hudCabBar=document.getElementById('cabinHPBar');
const hintEl=document.getElementById('hint'); const qBowEl=document.getElementById('qBow'), qSwordEl=document.getElementById('qSword'), qHammerEl=document.getElementById('qHammer');
hudMapW.textContent=Math.round(WORLD_WIDTH);

// ========= INPUT =========
const key=Object.create(null); const mouse={x:0,y:0,lmb:false,rmb:false,wheel:0};
addEventListener('keydown', e=>{ key[e.key.toLowerCase()]=true; if(e.key==='1') queueTool('bow'); if(e.key==='2') queueTool('sword'); if(e.key==='3') queueTool('hammer'); });
addEventListener('keyup', e=> key[e.key.toLowerCase()]=false);
addEventListener('blur', ()=>{ for(const k in key) delete key[k]; mouse.lmb=false; mouse.rmb=false; });
canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouse.x=e.clientX-r.left+camera.x; mouse.y=e.clientY-r.top+camera.y; });
canvas.addEventListener('contextmenu', e=> e.preventDefault());
canvas.addEventListener('mousedown', e=>{ if(e.button===0) mouse.lmb=true; if(e.button===2) mouse.rmb=true; });
canvas.addEventListener('mouseup', e=>{ if(e.button===0) mouse.lmb=false; if(e.button===2) mouse.rmb=false; });
canvas.addEventListener('wheel', e=>{ e.preventDefault(); mouse.wheel=e.deltaY; switchWeapon(mouse.wheel>0?1:-1); }, {passive:false});
addEventListener('keydown', e=>{ if(e.key.toLowerCase()==='e') tryBuyNearestInteractable(); });

// ========= CAMERA =========
const camera={x:0,y:0};
function ease(a, b, e){ return a + (b-a) * (1 - Math.pow(1-e, 2)); }
function centerOn(px,py){ const tx=clamp(px-canvas.width/DPR/2,0,WORLD_WIDTH-canvas.width/DPR), ty=clamp(py-canvas.height/DPR/2,0,WORLD_HEIGHT-canvas.height/DPR); camera.x=ease(camera.x,tx,CAMERA_EASE); camera.y=ease(camera.y,ty,CAMERA_EASE); }

// ========= TERRAIN =========
const hills=[], hillSegments=30; (function buildHills(){ const segW=WORLD_WIDTH/hillSegments; let x=0,y=GROUND_Y,amp=50; for(let i=0;i<hillSegments;i++){ const nx=x+segW, ny=GROUND_Y-Math.sin(i*.7)*amp*(.6+.4*Math.random()), cx=x+segW/2, cy=(y+ny)/2-amp*.4*Math.cos(i*.5); hills.push({x1:x,y1:y,cx,cy,x2:nx,y2:ny}); x=nx;y=ny; }})(); 
function groundHeightAt(px){ const segW=WORLD_WIDTH/hillSegments; const i=clamp(Math.floor(px/segW),0,hillSegments-1); const s=hills[i]; const t=clamp((px-s.x1)/(s.x2-s.x1),0,1); return (1-t)*(1-t)*s.y1+2*(1-t)*t*s.cy+t*t*s.y2; }

// ========= BACKGROUND using createPattern =========
const bg={far:null, mid:null, near:null, clouds:null, stars:null, ready:false, cloudX:0};

// stars strip
(function buildStars(){ const c=document.createElement('canvas'); c.width=WORLD_WIDTH; c.height=360; const g=c.getContext('2d'); g.fillStyle='rgba(255,255,255,0.85)';
  for(let i=0;i<900;i++){ const x=Math.random()*c.width, y=Math.random()*c.height, s=Math.random()*1.6+0.2; g.globalAlpha=0.2 + Math.random()*0.8; g.fillRect(x,y,s,s);}
  g.globalAlpha=1; bg.stars=c; })();

const userImg=new Image();
userImg.onload=()=>{ buildLayers(userImg); bg.ready=true; };
userImg.src="{DATA_URL}";

function buildLayers(img){
  bg.far  = makePatternLayer(img, 420, 1.10, 0.95);
  bg.mid  = makePatternLayer(img, 520, 1.06, 0.98);
  bg.near = makePatternLayer(img, 360, 1.02, 1.00);
  bg.clouds = buildCloudStrip(WORLD_WIDTH, 220);
}

// draws a horizontal repeating layer using createPattern to avoid seams
function makePatternLayer(img, outH, scaleMult, alpha){
  const s = (outH / img.height) * scaleMult;
  const tileW = Math.max(64, Math.round(img.width * s));
  const tileH = Math.round(img.height * s);
  const tile = document.createElement('canvas'); tile.width=tileW; tile.height=outH;
  const tg = tile.getContext('2d'); tg.imageSmoothingEnabled=true; tg.imageSmoothingQuality='high';
  const drawY = outH - tileH;
  tg.globalAlpha = alpha;
  tg.drawImage(img, 0, drawY, tileW, tileH);
  // 1px horizontal bleed to hide any sampling seam when patterned
  tg.drawImage(tile, 0, 0, 1, outH, tileW-1, 0, 1, outH);
  const c=document.createElement('canvas'); c.width=WORLD_WIDTH; c.height=outH; const g=c.getContext('2d');
  const pat=g.createPattern(tile, 'repeat-x'); g.fillStyle=pat; g.fillRect(0,0,WORLD_WIDTH,outH);
  return c;
}

function buildCloudStrip(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d');
  for(let i=0;i<120;i++){ const cx=Math.random()*w, cy=Math.random()*h*0.7, r=20+Math.random()*60, p=6+Math.random()*10; g.globalAlpha=0.08+Math.random()*0.08;
    for(let j=0;j<p;j++){ g.beginPath(); g.ellipse(cx+(Math.random()-0.5)*r, cy+(Math.random()-0.5)*r*0.5, r*(0.5+Math.random()*0.8), r*(0.25+Math.random()*0.5), 0, 0, Math.PI*2); g.fillStyle='#ffffff'; g.fill(); } }
  return c; }

function phaseDuration(){ return phase==='day'?BASE_PHASE_SECONDS*10:BASE_PHASE_SECONDS*2; }
function phaseElapsedSec(){ return (now()-phaseStart)/1000; }
function sunMoonPos(){
  const t=Math.max(0, Math.min(1, phaseElapsedSec()/phaseDuration()));
  const left=-canvas.width/DPR*0.2 + camera.x, right=camera.x + canvas.width/DPR*1.2;
  const x=left+(right-left)*t, topY=160, amp=180, y=topY + Math.sin(Math.PI*t) * -amp;
  return {x,y,t};
}

function skyGradient(){
  const t=Math.max(0, Math.min(1, phaseElapsedSec()/phaseDuration()));
  const et=t*t*(3-2*t);
  if(phase==='day') return ['rgba('+ (80+(210-80)*et)+','+(140+(200-140)*et)+','+(220+(255-220)*et)+',1)','rgba('+(170+(220-170)*et)+','+(210+(230-210)*et)+','+(255+(255-255)*et)+',1)'];
  return ['rgba('+(10+(40-10)*et)+','+(14+(40-14)*et)+','+(26+(80-26)*et)+',1)','rgba('+(20+(60-20)*et)+','+(24+(70-24)*et)+','+(44+(120-44)*et)+',1)'];
}

function drawBackground(dtMs){
  if(!bg.ready) return;
  // sky
  const cols=skyGradient(); const gSky=ctx.createLinearGradient(0,0,0,canvas.height/DPR);
  gSky.addColorStop(0,cols[0]); gSky.addColorStop(1,cols[1]); ctx.fillStyle=gSky; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);

  // clouds
  bg.cloudX = (bg.cloudX + dtMs*0.002) % (bg.clouds.width);
  ctx.globalAlpha = (phase==='day'?0.45:0.20);
  ctx.drawImage(bg.clouds, -camera.x*0.12 - bg.cloudX, 40);
  ctx.drawImage(bg.clouds, -camera.x*0.12 - bg.cloudX + bg.clouds.width, 40);
  ctx.globalAlpha = 1;

  // parallax
  ctx.drawImage(bg.far, -camera.x*0.18, 0);
  ctx.drawImage(bg.mid, -camera.x*0.28, 40);
  ctx.drawImage(bg.near, -camera.x*0.40, GROUND_Y-260);

  // subtle grade
  const sm=sunMoonPos();
  if(phase==='day'){ ctx.save(); ctx.globalCompositeOperation='multiply'; const g=ctx.createRadialGradient(sm.x, sm.y, 0, sm.x, sm.y, 420); g.addColorStop(0,'rgba(255,245,200,0.32)'); g.addColorStop(1,'rgba(255,220,150,0.10)'); ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR); ctx.restore(); }
  else { ctx.save(); ctx.globalCompositeOperation='multiply'; ctx.fillStyle='rgba(25,40,80,0.45)'; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR); ctx.restore(); }

  // vignette
  ctx.save(); ctx.globalCompositeOperation='multiply';
  const vg=ctx.createRadialGradient(canvas.width/DPR/2, canvas.height/DPR*0.75, 0, canvas.width/DPR/2, canvas.height/DPR*0.75, canvas.height/DPR*0.9);
  vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,0.25)'); ctx.fillStyle=vg; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR); ctx.restore();
}

// ========= (Trimmed) GAMEPLAY from v12 (only enough to test visuals) =========
const GRAVITY=0.9, FRICTION=0.86, MOVE_ACCEL=1.2, MAX_SPEED=8.7, RUN_MULT=1.35, JUMP=19.0;
const CROUCH_FACTOR=0.5, CROUCH_SPEED=0.8;
const BASE_PHASE_SECONDS=10;

class Entity{ constructor(x,y,w,h){ this.x=x;this.y=y;this.vx=0;this.vy=0;this.w=w;this.h=h;this.dir=1;this.crouching=false;this.grounded=false;this.hp=1;this.alive=true;this.type='generic';this.touchTimer=0;this.walkT=0; }
  get hitH(){ return this.crouching? this.h*CROUCH_FACTOR : this.h; } feetY(){ return this.y + this.hitH; } center(){ return {x:this.x+this.w/2,y:this.y+this.hitH/2}; }
  updatePhysics(dt){ this.vy += GRAVITY*dt; this.x += this.vx*dt; this.y += this.vy*dt; const gy=groundHeightAt(this.x+this.w/2)-2; if(this.feetY()>=gy){ this.y=gy-this.hitH; this.vy=0; this.grounded=true; } else this.grounded=false; if(this.x<0){this.x=0;this.vx=0;} if(this.x+this.w>WORLD_WIDTH){this.x=WORLD_WIDTH-this.w; this.vx=0;} if(Math.abs(this.vx)>0.2 && this.grounded) this.walkT+=dt*1.1; else this.walkT*=0.96; }}

const player=new Entity(WORLD_WIDTH/2-16, groundHeightAt(WORLD_WIDTH/2)-120, 38, 118);

function roundedRect(x,y,w,h,r){ r=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y, x+w,y+h, r); ctx.arcTo(x+w,y+h, x,y+h, r); ctx.arcTo(x,y+h, x,y, r); ctx.arcTo(x,y, x+w,y, r); ctx.closePath(); ctx.fill(); }
function triangle(cx, baseY, width, height){ ctx.beginPath(); ctx.moveTo(cx, baseY-height); ctx.lineTo(cx-width/2, baseY); ctx.lineTo(cx+width/2, baseY); ctx.closePath(); ctx.fill(); }

const cabin={ x:WORLD_WIDTH/2-140, w:280, h:170, get y(){return groundHeightAt(this.x+this.w/2)-this.h;} };

function drawTerrain(){
  ctx.save(); ctx.translate(-camera.x,-camera.y);
  ctx.fillStyle='#2f3a25'; ctx.beginPath(); ctx.moveTo(0,WORLD_HEIGHT); ctx.lineTo(0, groundHeightAt(0)); for(const seg of hills) ctx.quadraticCurveTo(seg.cx,seg.cy,seg.x2,seg.y2); ctx.lineTo(WORLD_WIDTH,WORLD_HEIGHT); ctx.closePath(); ctx.fill();
  ctx.lineWidth=5; ctx.strokeStyle='#7fb069'; ctx.beginPath(); ctx.moveTo(0, groundHeightAt(0)); for(let i=1;i<=200;i++){ const x=i/200*WORLD_WIDTH; ctx.lineTo(x, groundHeightAt(x)); } ctx.stroke();
  ctx.restore();
}

function drawCabin(){
  ctx.save(); ctx.translate(-camera.x,-camera.y);
  ctx.fillStyle='rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(cabin.x+cabin.w/2, cabin.y+cabin.h+8, cabin.w*0.45, 10, 0, 0, Math.PI*2); ctx.fill();
  const bodyGrad=ctx.createLinearGradient(0,cabin.y,0,cabin.y+cabin.h); bodyGrad.addColorStop(0,'#a57445'); bodyGrad.addColorStop(1,'#6f472c');
  ctx.fillStyle=bodyGrad; roundedRect(cabin.x,cabin.y,cabin.w,cabin.h,18);
  ctx.fillStyle='#4c3220'; roundedRect(cabin.x+cabin.w*0.4, cabin.y+cabin.h*0.45, cabin.w*0.2, cabin.h*0.55, 10);
  ctx.fillStyle='rgba(240,240,180,0.95)'; roundedRect(cabin.x+cabin.w*0.12, cabin.y+cabin.h*0.25, cabin.w*0.2, cabin.h*0.22, 8); roundedRect(cabin.x+cabin.w*0.68, cabin.y+cabin.h*0.25, cabin.w*0.2, cabin.h*0.22, 8);
  ctx.fillStyle='#6e4a31'; triangle(cabin.x+cabin.w/2, cabin.y, cabin.w*1.08, cabin.h*0.7);
  ctx.restore();
}

function drawPlayer(p){ ctx.save(); ctx.translate(-camera.x,-camera.y);
  const feet=p.y+p.hitH; ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.beginPath(); ctx.ellipse(p.x+p.w/2, feet+6, p.w*0.55, 6, 0, 0, Math.PI*2); ctx.fill();
  const headR=16, neckY=p.y+4, headX=p.x+p.w/2, headY=neckY+headR;
  ctx.fillStyle='#e0c2a3'; roundedRect(headX-5, neckY+headR-2, 10, 10, 4);
  ctx.fillStyle='#e5c9ac'; ctx.beginPath(); ctx.arc(headX, headY, headR, 0, Math.PI*2); ctx.fill();
  const torsoW=p.w*0.6, torsoH=p.hitH*0.58, torsoX=p.x+(p.w-torsoW)/2, torsoY=headY+6;
  const torsoGrad=ctx.createLinearGradient(0, torsoY, 0, torsoY+torsoH); torsoGrad.addColorStop(0,'#6a89ff'); torsoGrad.addColorStop(1,'#3e59a7');
  ctx.fillStyle=torsoGrad; roundedRect(torsoX, torsoY, torsoW, torsoH, 10);
  ctx.restore(); }

function render(dtMs){ drawBackground(dtMs); drawTerrain(); drawCabin(); drawPlayer(player);
  hudPhase.textContent=phase; const minutes=Math.floor(phaseElapsedSec()/60), seconds=Math.floor(phaseElapsedSec()%60).toString().padStart(2,'0'); hudTOD.textContent=minutes+':'+seconds; }

let phase='day', phaseStart=now();
function advancePhaseIfNeeded(){ if(phaseElapsedSec()>=phaseDuration()){ phase=(phase==='day')?'night':'day'; phaseStart=now(); } }

function tick(dt,dtMs){ const left=!!(key['a']||key['arrowleft']), right=!!(key['d']||key['arrowright']), jump=!!(key['w']||key['arrowup']||key[' ']), crouch=!!(key['s']||key['arrowdown']), run=!!key['shift'];
  const accel=(left?-1.2:0)+(right?1.2:0); const max=8.7*(run?1.35:1)*(crouch?0.8:1);
  player.vx=clamp((player.vx+accel)*(left||right?1:FRICTION), -max, max);
  if(jump && player.grounded) player.vy=-19.0;
  player.crouching=crouch; player.updatePhysics(dt); advancePhaseIfNeeded(); }

function frame(){ const t=now(); const dtMs=frame.prev? (t-frame.prev) : 16.6667; frame.prev=t; const dt=dtMs/16.6667;
  try{ tick(dt,dtMs); centerOn(player.x+player.w/2, player.y+player.hitH/2); render(dtMs); }catch(e){ showErr('Frame error: '+(e&&e.message?e.message:e)); }
  requestAnimationFrame(frame); }

const startX = WORLD_WIDTH/2 - canvas.width/DPR/2;
camera.x = clamp(startX, 0, WORLD_WIDTH - canvas.width/DPR);
camera.y = clamp(GROUND_Y - canvas.height/DPR/2, 0, WORLD_HEIGHT - canvas.height/DPR);
requestAnimationFrame(frame);

})();
</script>
</body>
</html>
""".replace("{DATA_URL}", data_url)

out = Path("/mnt/data/CabinDefense_v12_1_seamfix.html")
out.write_text(html, encoding="utf-8")
str(out)
